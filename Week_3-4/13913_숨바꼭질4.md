### 💡문제 분석

- 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)
- 동생은 점 K(0 ≤ K ≤ 100,000)
- 수빈이의 위치가 X일 때
    - 걷는다면 1초 후에 X-1 또는 X+1
    - 순간이동을 하는 경우에는 1초 후에 2*X
- 입력
    - 첫 번째 줄에 수빈이가 있는 위치 N, 동생이 있는 위치 K가 주어짐
        - N과 K는 정수
- 출력
    - 첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간
    - 둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 경로

---

### 💡입출력 예시

```python
##input
5 17

##output
4
5 10 9 18 17

##input
5 17

##output
4
5 4 8 16 17
```

---

### 💡코드

```python
from collections import deque

N, K = map(int, input().split())

visited = [-1] * 100001
prev = [-1] * 100001

q = deque()
q.append(N)
visited[N] = 0
prev[N] = -1

while q:
    X = q.popleft()
    if X == K:
        print(visited[X])
        
        path = []
        PX = X
        while PX != -1:
            path.append(PX)
            PX = prev[PX]
        print(*path[::-1])
        break
        
    for NX in (X+1, X-1, 2*X):
        if 0<= NX <= 100000 and visited[NX] == -1:
            visited[NX] = visited[X]+1
            prev[NX] = X
            q.append(NX)
```

---

### 💡시간복잡도

- O(N)

### 💡공간복잡도

- O(N)

---

### 💡메모

- 틀렸던 점
    - 부모 배열 사용시 `prev = [-1] * 100001` 선언을 누락함
        - IndexError
    - 반복문 내에서 이전과 현재 좌표 PX, X를 헷갈려서 무한 루프
        - 시간초과
    - 튜플에 ()안붙여서 append함
        - NameError
- 몰랐던 점
    - P라는 변수를 매 반복문마다 똑같이 사용함. 큐에 전달하면 다른 객체가 되는줄 알았음
        - new_path = P+[NX] 같은 방법으로 새로운 객체 만들기
    - 경로를 누적한 배열을 큐에 전달했는데 시간초과
        - 부모 배열을 만들어서 마지막에 for문을 통해 경로를 찾는게 훨씬 빠름