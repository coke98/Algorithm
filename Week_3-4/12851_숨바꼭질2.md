### 💡문제 분석

- 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)
- 동생은 점 K(0 ≤ K ≤ 100,000)
- 수빈이의 위치가 X일 때
    - 걷는다면 1초 후에 X-1 또는 X+1
    - 순간이동을 하는 경우에는 1초 후에 2*X
- 입력
    - 첫 번째 줄에 수빈이가 있는 위치 N, 동생이 있는 위치 K가 주어짐
        - N과 K는 정수
- 출력
    - 첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간
    - 둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수

---

### 💡입출력 예시

```python
##input
5 17

##output
4
2
```

---

### 💡코드

```python
from collections import deque

N, K = map(int,input().split())

visited = [-1] * 100001

q = deque()
q.append((N,0))
visited[N] = 0

min_time = -1

cnt = 0 

while q:
    X, T = q.popleft()
    if X == K:
        if min_time == -1:
            min_time = T
            cnt += 1
        elif min_time == T:
            cnt += 1
    if not min_time == -1:
        if T+1 > min_time:
            continue
     
    for nx in (2*X, X+1, X-1):
        if 0 <= nx <= 100000:
            if visited[nx] == -1 or visited[nx] == T+1:
                q.append((nx, T+1))
                visited[nx] = T+1
        
print(min_time)
print(cnt)
```

---

### 💡시간복잡도

- O(N)

### 💡공간복잡도

- O(N)

---

### 💡메모

- 틀렸던 점
    - visited가 필요없다고 생각했었음 → 1→-1 반복하는 경우가 생김 불필요한 연산
        - visited를 최초 -1, 그리고 이후는 도달 시간으로 표기하는 방법이 가능
    - 대입문에 == 를 씀
- 몰랐던 점
    - for nx in (2*X, X+1, X-1) 처럼 nx를 미리 정의해두고 꺼내 쓰는 방법을 사용할 수 있음