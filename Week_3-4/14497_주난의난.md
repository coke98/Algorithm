### 💡문제 분석

- N, M인 교실
    - (1 ≤ N, M ≤ 300)
- 빈칸: 0, 친구: 1, 주난: *, 범인: #
- 점프시 상하좌우 네 방향으로 친구들을 만날 때 까지 계속해서 퍼져나간다.
    - 파동에 맞은 친구들은 쓰러진다.
- 몇번째 점프만에 범인을 쓰러트릴 수 있는지 출력

---

### 💡입출력 예시

```python
# input
5 7
3 4 1 2
1#10111
1101001
001*111
1101111
0011001

# output
3

# input2
3 5
3 5 1 1
#0000
11111
0000*

# output2
2

# input3
3 3
2 2 1 1
#00
0*0
000

# output3
1
```

---

### 💡내 코드

```python
from collections import deque

N, M = map(int, input().split())
sy, sx, ty, tx = map(int, input().split())
sy, sx, ty, tx = sy-1, sx-1, ty-1, tx-1
matrix = [list(input()) for _ in range(N)]

answer = 1
dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

found = False

while not found:
    remove = set()
    visited = [[0]*M for _ in range(N)]
    visited[sy][sx] = 1
    q = deque()
    q.append((sx, sy))
    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0<= nx < M and 0<= ny < N and visited[ny][nx] == 0:
                visited[ny][nx] = 1
                if matrix[ny][nx] == '0':
                    q.append((nx,ny))
                if matrix[ny][nx] == '1':
                    remove.add((nx, ny))
                if matrix[ny][nx] == '#':
                    print(answer)
                    found = True
                    q = deque()
                    break
    for x, y in remove:
        matrix[y][x] = '0'
    answer += 1
```

---

### 💡시간복잡도

- $O((NM)2)$

### 💡공간복잡도

- $O(NM)$

---

### 💡메모

- 틀렸던 점
    - 1-indexed → 0-indexed 변환 누락
    - 시작점 방문 처리 누락
    - 입력으로 준 (x,y) 순서가 행·열 순서와 맞지 않음
- 개선할만한 점
    - 한번의 BFS로 1을 만날시 통과처리, 가중치 +1 을 통해 계산 가능$O(NM)$