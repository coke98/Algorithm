### 💡문제 분석

- 사다리게임
    - N개의 세로선, M개의 가로선
    - 인접한 세로선 사이에 가로선 놓을 수 있음
    - 세로선마다 놓을 수 있는 가로선은 H개임
    - 모든 세로선은 같은 가로 위치들을 공유한다
    - 두 가로선은 연속하거나 접하면 안됨
    - 각 세로선마다 게임 진행
        - 사다리 게임하듯이 가로선을 따라 이동
- i번 세로선의 결과가 i번이 나오도록 조작하려함
    - 추가해야하는 가로선의 최소값은?
- 입력
    - 첫째줄
        - 세로선의 개수 N
        - 가로선의 개수 M
        - 세로선마다 가로선을 놓을 수 있는 위치의 개수 H
        - (2 ≤ N ≤ 10, 1 ≤ H ≤ 30, 0 ≤ M ≤ (N-1)×H)
    - 둘째줄부터 M개의 줄
        - 가로선의 정보가 한 줄에 하나씩 주어짐
        - a, b로 나타냄
            - b번 세로선과 b+1번 세로선을 a번 점선 위치에서 연결
    - 가로선이 서로 연속하는 경우는 없다.
- 출력
    - 가로선 개수의 최소값
    - 정답이 3보다 크면 -1
    - 불가능한 경우 -1

---

### 💡입출력 예시

```python
예제 입력 1 
2 0 3
예제 출력 1 
0

예제 입력 2 
2 1 3
1 1
예제 출력 2 
1

예제 입력 3 
5 5 6
1 1
3 2
2 3
5 1
5 4
예제 출력 3 
3

예제 입력 4 
6 5 6
1 1
3 2
1 3
2 5
5 5
예제 출력 4 
3

예제 입력 5 
5 8 6
1 1
2 2
3 3
4 4
3 1
4 2
5 3
6 4
예제 출력 5 
-1

예제 입력 6 
5 12 6
1 1
1 3
2 2
2 4
3 1
3 3
4 2
4 4
5 1
5 3
6 2
6 4
예제 출력 6 
-1

예제 입력 7 
5 6 6
1 1
3 1
5 2
4 3
2 3
1 4
예제 출력 7 
2
```

---

### 💡코드

```python
from itertools import combinations

N, M, H = map(int, input().split())
ladder = [[False]*(N+1) for _ in range(H+1)]
for _ in range(M):
    a, b = map(int, input().split())
    ladder[a][b] = True

def check():
    for start in range(1, N+1):
        pos = start
        for h in range(1, H+1):
            if ladder[h][pos]:
                pos += 1
            elif pos > 1 and ladder[h][pos-1]:
                pos -= 1
        if pos != start:
            return False
    return True

cands = []
for h in range(1, H+1):
    for x in range(1, N):
        if not ladder[h][x] and not ladder[h][x-1] and not ladder[h][x+1]:
            cands.append((h, x))

if check():
    print(0)
    exit()

for k in range(1, 4):
    for comb in combinations(cands, k):
        bad = False
        for (h1, x1), (h2, x2) in combinations(comb, 2):
            if h1 == h2 and abs(x1 - x2) == 1:
                bad = True
                break
        if bad:
            continue
        for h, x in comb:
            ladder[h][x] = True
        if check():
            print(k)
            exit()
        for h, x in comb:
            ladder[h][x] = False

print(-1)

```

---

### 💡메모

- 몰랐던 점
    - combination으로 했더니 시간 초과

    ```python
    from itertools import combinations
    
    N, M, H = map(int, input().split())
    path = [tuple(map(int, input().split())) for _ in range(M)]
    
    valid_path = []
    
    for a in range(1, H+1):
        for b in range(1, N):
            if (a,b) not in path:
                valid_path.append((a, b))
            
    def is_serial(path):
        is_serial = False
        d = dict()
        for p in path:
            a, b = p[0], p[1]
            if a in d and d[a]+1 == b:
                is_serial = True
            else:
                d[a] = b
        return is_serial
    
    def move(cur, j, path):
        if (j, cur) in path:
            return 1
        elif (j, cur-1) in path:
            return -1
        else:
            return 0
    
    def is_answer(N, H, path):
        for i in range(1, N+1):
            cur = i
            for j in range(1, H+1):
                cur += move(cur, j, path)
            if not cur == i:
                return False
        return True
    
    found = False
    for t in range(4):
        for combo in combinations(valid_path, t):
            new_path = sorted(path+list(combo))
            if is_serial(new_path):
                continue
            if is_answer(N, H, new_path):
                print(t)
                found = True
                break
        if found:
            break
            
    if not found:
        print('-1')
            
    ```

  dfs로 했더니 마찬가지로 시간 초과

    ```python
    from collections import deque
    
    N, M, H = map(int, input().split())
    path = {(a, b) for a, b in (map(int, input().split()) for _ in range(M))}
    
    def check_ladder(cur):
        for start in range(1, N+1):
            pos = start
            for h in range(1, H+1):
                if (h, pos) in path or (h, pos) in cur:
                    pos += 1
                elif (h, pos-1) in path or (h, pos-1) in cur:
                    pos -= 1
            if pos != start:
                return False
        return True
    
    cands = [(h, x)
        for h in range(1, H+1)
        for x in range(1, N)
        if (h, x) not in path
        and (h, x-1) not in path
        and (h, x+1) not in path
    ]
    
    answer = 4
    
    def dfs():
        global answer
        stack = deque()
        stack.append((0, ()))
        
        while stack:
            idx, cur = stack.pop()
            cnt = len(cur)
            if cnt >= answer or cnt > 3:
                continue
            if check_ladder(cur):
                answer = cnt
                if answer == 0:
                    return
                continue
            for i in range(idx, len(cands)):
                h, x = cands[i]
                if any(h==hy and abs(x-hx)==1 for hy,hx in cur):
                    continue
                stack.append((i+1, cur + ((h, x),)))
    
    dfs()
    print(answer if answer <= 3 else -1)
    ```

    - cur + move()의 결과를 cur에 삽입하지 않고 지나감