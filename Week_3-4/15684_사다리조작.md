### ðŸ’¡ë¬¸ì œ ë¶„ì„

- ì‚¬ë‹¤ë¦¬ê²Œìž„
    - Nê°œì˜ ì„¸ë¡œì„ , Mê°œì˜ ê°€ë¡œì„ 
    - ì¸ì ‘í•œ ì„¸ë¡œì„  ì‚¬ì´ì— ê°€ë¡œì„  ë†“ì„ ìˆ˜ ìžˆìŒ
    - ì„¸ë¡œì„ ë§ˆë‹¤ ë†“ì„ ìˆ˜ ìžˆëŠ” ê°€ë¡œì„ ì€ Hê°œìž„
    - ëª¨ë“  ì„¸ë¡œì„ ì€ ê°™ì€ ê°€ë¡œ ìœ„ì¹˜ë“¤ì„ ê³µìœ í•œë‹¤
    - ë‘ ê°€ë¡œì„ ì€ ì—°ì†í•˜ê±°ë‚˜ ì ‘í•˜ë©´ ì•ˆë¨
    - ê° ì„¸ë¡œì„ ë§ˆë‹¤ ê²Œìž„ ì§„í–‰
        - ì‚¬ë‹¤ë¦¬ ê²Œìž„í•˜ë“¯ì´ ê°€ë¡œì„ ì„ ë”°ë¼ ì´ë™
- ië²ˆ ì„¸ë¡œì„ ì˜ ê²°ê³¼ê°€ ië²ˆì´ ë‚˜ì˜¤ë„ë¡ ì¡°ìž‘í•˜ë ¤í•¨
    - ì¶”ê°€í•´ì•¼í•˜ëŠ” ê°€ë¡œì„ ì˜ ìµœì†Œê°’ì€?
- ìž…ë ¥
    - ì²«ì§¸ì¤„
        - ì„¸ë¡œì„ ì˜ ê°œìˆ˜ N
        - ê°€ë¡œì„ ì˜ ê°œìˆ˜ M
        - ì„¸ë¡œì„ ë§ˆë‹¤ ê°€ë¡œì„ ì„ ë†“ì„ ìˆ˜ ìžˆëŠ” ìœ„ì¹˜ì˜ ê°œìˆ˜ H
        - (2 â‰¤ N â‰¤ 10, 1 â‰¤ H â‰¤ 30, 0 â‰¤ M â‰¤ (N-1)Ã—H)
    - ë‘˜ì§¸ì¤„ë¶€í„° Mê°œì˜ ì¤„
        - ê°€ë¡œì„ ì˜ ì •ë³´ê°€ í•œ ì¤„ì— í•˜ë‚˜ì”© ì£¼ì–´ì§
        - a, bë¡œ ë‚˜íƒ€ëƒ„
            - bë²ˆ ì„¸ë¡œì„ ê³¼ b+1ë²ˆ ì„¸ë¡œì„ ì„ aë²ˆ ì ì„  ìœ„ì¹˜ì—ì„œ ì—°ê²°
    - ê°€ë¡œì„ ì´ ì„œë¡œ ì—°ì†í•˜ëŠ” ê²½ìš°ëŠ” ì—†ë‹¤.
- ì¶œë ¥
    - ê°€ë¡œì„  ê°œìˆ˜ì˜ ìµœì†Œê°’
    - ì •ë‹µì´ 3ë³´ë‹¤ í¬ë©´ -1
    - ë¶ˆê°€ëŠ¥í•œ ê²½ìš° -1

---

### ðŸ’¡ìž…ì¶œë ¥ ì˜ˆì‹œ

```python
ì˜ˆì œ ìž…ë ¥ 1 
2 0 3
ì˜ˆì œ ì¶œë ¥ 1 
0

ì˜ˆì œ ìž…ë ¥ 2 
2 1 3
1 1
ì˜ˆì œ ì¶œë ¥ 2 
1

ì˜ˆì œ ìž…ë ¥ 3 
5 5 6
1 1
3 2
2 3
5 1
5 4
ì˜ˆì œ ì¶œë ¥ 3 
3

ì˜ˆì œ ìž…ë ¥ 4 
6 5 6
1 1
3 2
1 3
2 5
5 5
ì˜ˆì œ ì¶œë ¥ 4 
3

ì˜ˆì œ ìž…ë ¥ 5 
5 8 6
1 1
2 2
3 3
4 4
3 1
4 2
5 3
6 4
ì˜ˆì œ ì¶œë ¥ 5 
-1

ì˜ˆì œ ìž…ë ¥ 6 
5 12 6
1 1
1 3
2 2
2 4
3 1
3 3
4 2
4 4
5 1
5 3
6 2
6 4
ì˜ˆì œ ì¶œë ¥ 6 
-1

ì˜ˆì œ ìž…ë ¥ 7 
5 6 6
1 1
3 1
5 2
4 3
2 3
1 4
ì˜ˆì œ ì¶œë ¥ 7 
2
```

---

### ðŸ’¡ì½”ë“œ

```python
from itertools import combinations

N, M, H = map(int, input().split())
ladder = [[False]*(N+1) for _ in range(H+1)]
for _ in range(M):
    a, b = map(int, input().split())
    ladder[a][b] = True

def check():
    for start in range(1, N+1):
        pos = start
        for h in range(1, H+1):
            if ladder[h][pos]:
                pos += 1
            elif pos > 1 and ladder[h][pos-1]:
                pos -= 1
        if pos != start:
            return False
    return True

cands = []
for h in range(1, H+1):
    for x in range(1, N):
        if not ladder[h][x] and not ladder[h][x-1] and not ladder[h][x+1]:
            cands.append((h, x))

if check():
    print(0)
    exit()

for k in range(1, 4):
    for comb in combinations(cands, k):
        bad = False
        for (h1, x1), (h2, x2) in combinations(comb, 2):
            if h1 == h2 and abs(x1 - x2) == 1:
                bad = True
                break
        if bad:
            continue
        for h, x in comb:
            ladder[h][x] = True
        if check():
            print(k)
            exit()
        for h, x in comb:
            ladder[h][x] = False

print(-1)

```

---

### ðŸ’¡ë©”ëª¨

- ëª°ëžë˜ ì 
    - combinationìœ¼ë¡œ í–ˆë”ë‹ˆ ì‹œê°„ ì´ˆê³¼

    ```python
    from itertools import combinations
    
    N, M, H = map(int, input().split())
    path = [tuple(map(int, input().split())) for _ in range(M)]
    
    valid_path = []
    
    for a in range(1, H+1):
        for b in range(1, N):
            if (a,b) not in path:
                valid_path.append((a, b))
            
    def is_serial(path):
        is_serial = False
        d = dict()
        for p in path:
            a, b = p[0], p[1]
            if a in d and d[a]+1 == b:
                is_serial = True
            else:
                d[a] = b
        return is_serial
    
    def move(cur, j, path):
        if (j, cur) in path:
            return 1
        elif (j, cur-1) in path:
            return -1
        else:
            return 0
    
    def is_answer(N, H, path):
        for i in range(1, N+1):
            cur = i
            for j in range(1, H+1):
                cur += move(cur, j, path)
            if not cur == i:
                return False
        return True
    
    found = False
    for t in range(4):
        for combo in combinations(valid_path, t):
            new_path = sorted(path+list(combo))
            if is_serial(new_path):
                continue
            if is_answer(N, H, new_path):
                print(t)
                found = True
                break
        if found:
            break
            
    if not found:
        print('-1')
            
    ```

  dfsë¡œ í–ˆë”ë‹ˆ ë§ˆì°¬ê°€ì§€ë¡œ ì‹œê°„ ì´ˆê³¼

    ```python
    from collections import deque
    
    N, M, H = map(int, input().split())
    path = {(a, b) for a, b in (map(int, input().split()) for _ in range(M))}
    
    def check_ladder(cur):
        for start in range(1, N+1):
            pos = start
            for h in range(1, H+1):
                if (h, pos) in path or (h, pos) in cur:
                    pos += 1
                elif (h, pos-1) in path or (h, pos-1) in cur:
                    pos -= 1
            if pos != start:
                return False
        return True
    
    cands = [(h, x)
        for h in range(1, H+1)
        for x in range(1, N)
        if (h, x) not in path
        and (h, x-1) not in path
        and (h, x+1) not in path
    ]
    
    answer = 4
    
    def dfs():
        global answer
        stack = deque()
        stack.append((0, ()))
        
        while stack:
            idx, cur = stack.pop()
            cnt = len(cur)
            if cnt >= answer or cnt > 3:
                continue
            if check_ladder(cur):
                answer = cnt
                if answer == 0:
                    return
                continue
            for i in range(idx, len(cands)):
                h, x = cands[i]
                if any(h==hy and abs(x-hx)==1 for hy,hx in cur):
                    continue
                stack.append((i+1, cur + ((h, x),)))
    
    dfs()
    print(answer if answer <= 3 else -1)
    ```

    - cur + move()ì˜ ê²°ê³¼ë¥¼ curì— ì‚½ìž…í•˜ì§€ ì•Šê³  ì§€ë‚˜ê°