### 💡문제 분석

- 직사각형 종이
    - 각칸 숫자
    - 각 조각은 세로 혹은 가로가 1인 직사각형
    - 길이가 N인 조각은 N자리수로 읽음
        - 위에서 아래, 왼쪽에서 오른쪽으로 읽음
- 직사각형을 임의로 만들어 조각낼 때 각 조각의 합은?

---

### 💡입출력 예시

```python
예제 입력 1 
2 3
123
312
예제 출력 1 
435

예제 입력 2 
2 2
99
11
예제 출력 2 
182

예제 입력 3 
4 3
001
010
111
100
예제 출력 3 
1131

예제 입력 4 
1 1
8
예제 출력 4 
8
```

---

### 💡내 코드

```python
N, M = map(int, input().split())

matrix = [[int(i) for i in input()] for _ in range(N)]

answer = 0

def is_row_head(M, combi, row, col):
    prev_col = col - 1
    if prev_col < 0:
        return True
    i = M * row + prev_col
    if combi >> i & 1 == 0:
        return True
    return False

def is_col_head(M, combi, row, col):
    prev_row = row - 1
    if prev_row < 0:
        return True
    i = M * prev_row + col
    if combi >> i & 1 == 1:
        return True
    return False

def find_row_num(M, combi, row, col):
    num = 0
    for dx in range(M-col):
        if combi >> (M * row + col + dx) & 1 == 0:
            break
        num *= 10
        num += matrix[row][col+dx]
    return num

def find_col_num(N, M, combi, row, col):
    num = 0
    for dy in range(N-row):
        if combi >> (M * (row+dy) + col) & 1 == 1:
            break
        num *= 10
        num += matrix[row+dy][col]
    return num

for combi in range(1 << N*M):
    s = 0
    for i in range(N*M):
        row = i // M
        col = i % M
        val = combi >> i
        if val & 1 == 1:
            if is_row_head(M, combi, row, col):
                s += find_row_num(M, combi, row, col)
        else:
            if is_col_head(M, combi, row, col):
                s += find_col_num(N, M, combi, row, col)
    answer = max(answer, s)

print(answer)       
```

---

### 💡시간복잡도

- $O(2^{N \times M} \times N \times M)$

### 💡공간복잡도

- $O(NM)$

---

### 💡메모

- 틀렸던 점
    - **`range()` 함수 오류**
        - **문제점:** `range(0 << N*M)`는 비트 연산 결과 항상 `0`이 됨. 따라서 `range(0)`이 되어 반복문이 아예 실행되지 않음.
        - **해결책:** 모든 경우의 수를 탐색하기 위해 `range(1 << N*M)` 또는 `range(2**(N*M))`으로 수정해야 함. `1 << x`는 2x 와 같음.

    ---

    - **`&` 비트 연산자 오용**
        - **문제점:** `combi >> i & 0`처럼 0과 AND 연산 시 무조건 결과가 `0`이 나옴. 이 때문에 조건문이 항상 `False`가 됨.
        - **해결책:** 특정 비트가 0인지 1인지 확인하려면 `& 1`을 사용해야 함.
            - `1`인 경우: `(combi >> i) & 1 == 1`
            - `0`인 경우: `(combi >> i) & 1 == 0`

    ---

    - **`s` 변수 초기화 위치**
        - **문제점:** `s = 0`이 `for combi` 반복문 밖에 있어 합계가 누적됨.
        - **해결책:** 각 경우의 수마다 합계를 새로 계산해야 하므로 `s = 0`을 **`for combi` 반복문 안쪽**에 둬야 함.

    ---

    - **`if`문 논리 오류**
        - **문제점:** 가로 조각(`if val & 1 == 1:`) 다음으로 세로 조각(`if val & 1 == 0:`)을 따로 처리함.
        - **해결책:** 모든 칸은 가로 또는 세로 조각 둘 중 하나이므로, `else` 구조를 사용하는 것이 더 효율적이고 논리적으로 정확함.

    ---

    - **BFS로 풀었더니 시간초과 → 비트마스크로 풀어야함**

        ```python
        # BFS 풀이 시도
        
        from collections import deque
        
        N, M = map(int, input().split())
        matrix = [[int(i) for i in input()] for _ in range(N)]
        
        q = deque()
        q.append((0, []))
        
        answer = 0
        
        while q:
            s, v = q.popleft()
            if len(v) == N * M:
                answer = max(answer, s)
            for y in range(N):
                for x in range(M):
                    if (y, x) in v:
                        continue
                    # 하나만 넣기
                    ns = s+matrix[y][x]
                    nv = v + [(y,x)]
                    q.append((ns, nv))
                    # 가로로 조각별로 넣기
                    i = 1
                    while True:
                        if (y, x+i) in v or x+i >= M:
                            break
                        ns = s
                        nv = list(v)
                        for dx in range(i+1):
                            ns += matrix[y][x+dx]
                            nv.append((y,x+dx))
                            q.append((ns, nv))
                        i += 1
                    # 세로로 조각별로 넣기
                    i = 1
                    while True:
                        if (y+i, x) in v or y+i >= N:
                            break
                        ns = s
                        nv = list(v)
                        for dy in range(i+1):
                            ns += matrix[y+dy][x]
                            nv.append((y+dy, x))
                            q.append((ns, nv))
                        i += 1
                            
        print(answer)
        ```