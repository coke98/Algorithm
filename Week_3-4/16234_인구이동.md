### ğŸ’¡ë¬¸ì œ ë¶„ì„

- NÃ—Ní¬ê¸°ì˜ ë•…
- ë•…ì€ 1Ã—1ê°œì˜ ì¹¸
- ê°ê°ì˜ ë•…ì—ëŠ” ë‚˜ë¼ê°€ í•˜ë‚˜ì”© ì¡´ì¬
- rí–‰ cì—´ì— ìˆëŠ” ë‚˜ë¼ì—ëŠ” A[r][c]ëª…ì´ ì‚´ê³  ìˆìŒ
- ì¸ì ‘í•œ ë‚˜ë¼ ì‚¬ì´ì—ëŠ” êµ­ê²½ì„ ì´ ì¡´ì¬
    - ëª¨ë“  êµ­ê²½ì„ ì€ ì •ì‚¬ê°í˜• í˜•íƒœ
- ì¸êµ¬ ì´ë™ì€ í•˜ë£¨ ë™ì•ˆ
    - êµ­ê²½ì„ ì„ ê³µìœ í•˜ëŠ” ë‘ ë‚˜ë¼ì˜ ì¸êµ¬ ì°¨ì´ê°€ Lëª… ì´ìƒ, Rëª… ì´í•˜ì¼ ê²½ìš°, êµ­ê²½ì„  ê°œë°© í›„ ì—°í•©
    - ê° ì¹¸ì˜ ì¸êµ¬ìˆ˜ëŠ” (ì—°í•©ì˜ ì¸êµ¬ìˆ˜) / (ì—°í•©ì„ ì´ë£¨ê³  ìˆëŠ” ì¹¸ì˜ ê°œìˆ˜)
    - ì†Œìˆ˜ì ì€ ë²„ë¦°ë‹¤
    - ì—°í•©ì„ í•´ì²´ ë° êµ­ê²½ì„  íì‡„
- ì¸êµ¬ ì´ë™ì´ ë©°ì¹  ë™ì•ˆ ë°œìƒí•˜ëŠ”ì§€ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±
- ì…ë ¥
    - ì²«ì§¸ ì¤„ì— N, L, R (1 â‰¤ N â‰¤ 50, 1 â‰¤ L â‰¤ R â‰¤ 100)
    - ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì— ê° ë‚˜ë¼ì˜ ì¸êµ¬ìˆ˜ (0 â‰¤ A[r][c] â‰¤ 100)
    - ì¸êµ¬ ì´ë™ì´ ë°œìƒí•˜ëŠ” ì¼ìˆ˜ê°€ 2,000ë²ˆ ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ì…ë ¥ë§Œ ì£¼ì–´ì§
- ì¶œë ¥
    - ì¸êµ¬ì´ë™ì´ ë°œìƒí•˜ëŠ” ì¼ìˆ˜

---

### ğŸ’¡ì…ì¶œë ¥ ì˜ˆì‹œ

```python
##input
2 20 50
50 30
20 40

##output
1

##input2
4 10 50
10 100 20 90
80 100 60 70
70 20 30 40
50 20 100 10

##output2
3
```

---

### ğŸ’¡ì½”ë“œ

```python
N, L, R =  map(int, input().split())
A = [list(map(int,input().split())) for _ in range(N)]

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0]*n
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.rank[ra] < self.rank[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        if self.rank[ra] == self.rank[rb]:
            self.rank[ra] += 1
        return True

def idx(x, y): return y*N + x

dx = [0,0,1,-1]
dy = [1,-1,0,0]

answer = 0

while True:
    uf = UnionFind(N*N)
    
    for y in range(N):
        for x in range(N):
            for i in range(4):
                nx, ny = x+dx[i], y+dy[i]
                if 0 <= nx < N and 0 <= ny < N and L <= abs(A[y][x] - A[ny][nx]) <= R:
                    uf.union(idx(x,y),idx(nx,ny))
    groups = {}            
    for y in range(N):
        for x in range(N):
            root = uf.find(idx(x,y))
            if root not in groups:
                groups[root] = []
            groups[root].append((x,y))
            
    moved = False
    for nations in groups.values():
        if len(nations) > 1:
            moved = True
            total = sum(A[y][x] for x, y in nations)
            avg = total // len(nations)
            for x, y in nations:
                A[y][x] = avg
         
    if not moved:
        break
    answer += 1
    
print(answer)
        
        

```

---

### ğŸ’¡ì‹œê°„ë³µì¡ë„

- í‰ê·  O(NÂ²)
- ìµœì•… O(Nâ´)

### ğŸ’¡ê³µê°„ë³µì¡ë„

- O(NÂ²)

---

### ğŸ’¡ë©”ëª¨

- í‹€ë ¸ë˜ ì 
    - dx,dyì— [i] ë¹ ì§
    - uf.union ëŒ€ì‹  unionìœ¼ë¡œ í˜¸ì¶œ
    - moved True â†’ moved = True ëŒ€ì…ë¬¸ ì•ˆë„£ìŒ
    - ì¢Œí‘œ ì–¸íŒ¨í‚¹ ìˆœì„œ ë°˜ëŒ€ë¡œ í•¨
        - groupsì— (y,x) ë¡œ ì €ì¥ í–ˆìœ¼ë¯€ë¡œ y, xë¡œ êº¼ë‚´ì•¼ í–ˆìŒ
- ê°œì„ í• ë§Œí•œ ì 
    - bfsë¡œ í‘¸ëŠ”ê²Œ ì˜¤ë²„í—¤ë“œê°€ ë” ì ìŒ