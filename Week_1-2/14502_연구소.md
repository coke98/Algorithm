### 💡문제 분석

- N, M인 직사각형 연구소
    - (3 ≤ N, M ≤ 8)
- 빈칸: 0, 벽: 1, 바이러스: 2
    - (2 ≤ 2의 개수 ≤ 10)
- 바이러스는 상하좌우로 인접하면 퍼짐
- 벽을 3개 세워야만함
- 바이러스가 퍼졌을때 빈칸아 가장 많은 경우의 빈칸의 수를 출력

---

### 💡입출력 예시

```python
# input
7 7
2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0

# output
27

# input2
4 6
0 0 0 0 0 0
1 0 0 0 0 2
1 1 1 0 0 2
0 0 0 0 0 2

# output2
9

# input3
8 8
2 0 0 0 0 0 0 2
2 0 0 0 0 0 0 2
2 0 0 0 0 0 0 2
2 0 0 0 0 0 0 2
2 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

# output3
3

```

---

### 💡내 코드

```python
from itertools import combinations
from collections import deque

N, M = map(int, input().split())

matrix = [list(map(int, input().split())) for _ in range(N)]
blank = []

for y in range(N):
    for x in range(M):
        cur = matrix[y][x]
        if cur == 0:
            blank.append((x,y))
            
            
dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

answer = 0

for cbn in combinations(blank, 3):
    visited = [[0]*M for _ in range(N)]
    safe_area = 0
    for y in range(N):
        for x in range(M):
            cur = matrix[y][x]        
            if cur == 0 and (x,y) not in cbn and visited[y][x] == 0:
                q = deque()
                q.append((x,y))
                visited[y][x] = 1
                safe = True
                cnt = 1
                while q:
                    cx, cy = q.popleft()
                    for i in range(4):
                        nx, ny = cx + dx[i], cy + dy[i]
                        if ((nx, ny) not in cbn 
                            and 0 <= nx < M and 0 <= ny < N 
                            and visited[ny][nx] == 0):
                            if matrix[ny][nx] == 0:
                                visited[ny][nx] = 1
                                cnt += 1
                                q.append((nx,ny))
                                
                            if matrix[ny][nx] == 2:
                                safe = False
                if safe:
                    safe_area += cnt
    answer = max(answer, safe_area)
print(answer)

```

---

### 💡시간복잡도

- O((NM)⁴)

### 💡공간복잡도

- O(NM)

---

### 💡메모

- 틀렸던 점
    - for cbn for combinations(blank, 3) 으로 잘못씀
    - matrix = [map(int, input().split()) for _ in range(N)] 로 리스트를 맵에 안씌워줌
    - visited == 0으로 2차원 배열 자체를 비교하였음
    - 붙어있는 빈칸 영역중 가장 큰 것으로 문제를 오해함
- 개선할만한 점
    - bfs를 빈칸시점이 아니라 상대적으로 수가 적은 바이러스 시점에서 시행한 후 빈칸을 세주면 더 빨라질 가능성이 있음