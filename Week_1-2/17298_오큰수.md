### 💡문제 분석

- 수열에서 $A_i$의 오큰수를 구하고자 함
    - $A_i$의 오른쪽에 있으면서, $A_i$보다 큰 수 중 가장 왼쪽에 있는 수
    - 없다면 -1
- 입력
    - 첫째줄
        - 수열의 크기
            - 1≤ 수열 크기 ≤ 1,000,000
    - 둘째줄
        - 수열의 원소
            - 1≤수열원소<1,000,000
- 출력
    - 총 N개수의 오큰수를 각각 공백으로 구분해 출력

---

### 💡입출력 예시

```python
##input
4
3 5 2 7

##output
5 7 7 -1

##input2
4
9 5 4 8

##output2
-1 8 8 -1
```

---

### 💡코드

```python
import heapq

N = int(input())
A = list(map(int, input().split()))

hq = []
heapq.heappush(hq, (A[0],0))
answer = [0]*N

for i, a in enumerate(A[1:], start = 1):
	heapq.heappush(hq,(a,i))
	while hq[0][0] < a:
		num, idx = heapq.heappop(hq)
		answer[idx] = a

while hq:
	num, idx = heapq.heappop(hq)
	answer[idx] = -1

print(*answer)
```

---

### 💡시간복잡도

- O(Nlog(N))

### 💡공간복잡도

- O(N)

---

### 💡메모

- 몰랐던 점
    - enumerate에서 1부터 시작하고 싶다면 enumerate(A[1:], start = 1)
    - 파이썬 heap 사용법

    ```python
    import heapq
    heap = []
    heapq.heappush(1)
    
    while heap:
    	top = heap[0]
    	heapq.heappop()
    ```

- 틀렸던 점
    - hq로 정의해놓고 heap 이라고 변수를 사용
    - int(input)으로 input()에 괄호 안붙임
- 개선할만한 점
    - 스택으로 오큰수를 관리 → O(N)

        ```python
        N = int(input())
        nums = list(map(int, input().split()))
        result = [-1]*N
        stack = []
        
        for i in range(N-1, -1, -1):
            while stack and stack[-1] <= nums[i]:
                stack.pop()
            if stack:
                result[i] = stack[-1]
            stack.append(nums[i])
            
        print(*result)
        ```