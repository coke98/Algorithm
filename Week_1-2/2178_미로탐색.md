### π’΅λ¬Έμ  λ¶„μ„

- N*M ν¬κΈ°μ λ°°μ—΄λ΅ λ―Έλ΅ ν‘ν„
- 1μ€ μ΄λ™ κ°€λ¥, 0μ€ μ΄λ™ λ¶κ°€
- (1, 1)μ—μ„ μ¶λ°ν•΄ (N, M)κΉμ§€ μ΄λ™ν•λ”λ° κ±Έλ¦¬λ” μµμ† μΉΈ μ κµ¬ν•κΈ°
- μ„λ΅ μΈμ ‘ν• μΉΈλ§ μ΄λ™ κ°€λ¥
- μΉΈμ„ μ…€ λ• μ‹μ‘μ κ³Ό λ„μ°©μ λ„ ν¬ν•¨
- μ²«μ§Έμ¤„μ— N, M(2 β‰¤ N, M β‰¤ 100)μ΄ μ£Όμ–΄μ§
- Nκ° μ¤„μ— Mκ°μ μ •μ λ―Έλ΅κ°€ μ£Όμ–΄μ§
- κ° μλ” λ¶™μ–΄μ„ μ…λ ¥μΌλ΅ μ£Όμ–΄μ§

---

### π’΅μ…μ¶λ ¥ μμ‹

```python
##input
4 6
101111
101010
101011
111011

##output
15
```

```python
##input
4 6
110110
110110
111111
111101

##output
9
```

---

### π’΅μ½”λ“

```python
from collections import deque

N, M = map(int, input().split())
maze = [[int(c) for c in input()] for _ in range(N)]

q = deque()
q.append((1,1,1))

dy = [0, 0, 1, -1]
dx = [1, -1, 0, 0]

while q:
    cur = q.popleft()
    cy = cur[0]
    cx = cur[1]
    attempt = cur[2]
    
    if maze[cy-1][cx-1] == -1:
        continue
    
    maze[cy-1][cx-1] = -1
    
    for i in range(4):
        ny = cy+dy[i]
        nx = cx+dx[i]
        if 0 < nx <= M and 0 < ny <= N and maze[ny-1][nx-1] == 1:
            q.append((ny,nx,attempt+1))
            
    if cy == N and cx == M:
        print(attempt)
        break
```

---

### π’΅μ‹κ°„λ³µμ΅λ„

- O(N*M)

### π’΅κ³µκ°„λ³µμ΅λ„

- O(N*M)

---

### π’΅λ©”λ¨

- ν‹€λ¦° μ 
    - λ²”μ„ μ²΄ν¬μ‹ μΈλ±μ¤κ°€ 0λ³΄λ‹¤ ν°μ§€λ§ ν™•μΈν• μ , M, N λ³΄λ‹¤ μ‘μ•„μ•Όν•¨
    - bfsμ—μ„ κ°€μ¥ λ¨Όμ € visitedμΈμ§€ ν™•μΈν•κΈ°
    - λ‹¤μ λ…Έλ“λ¥Ό ν™•μΈν•  λ•, ny = cy+dy[i], nx = cx+dx[i]μ—μ„ +λ€μ‹  λ¬΄μμ‹μ μΌλ΅ -λ¥Ό μ“΄μ 
- λ°λλ μ 
    - {}λ” λ¦¬μ¤νΈκ°€ μ•„λ‹ μ§‘ν•©, μΈλ±μ¤ μ‚¬μ©μ‹ νν” ()μ΄λ‚ []λ¦¬μ¤νΈ ν•νƒλ¥Ό μ‚¬μ©ν•κΈ°
    - from collections import deque, append(), popleft() λ΅ ν μ‚¬μ©
- μν• μ 
    - λ°©ν–¥μ„ λ¦¬μ¤νΈλ΅ κ΄€λ¦¬
    - λ°©λ¬Έν• κ³³μ„ -1λ΅ λ°”κΏμΌλ΅μ¨ λ©”λ¨λ¦¬ ν¨μ¨
    - μΈλ±μ¤ κ³„μ‚° μ• ν—·κ°λ¦¬κ³  ν•μ 