### 💡문제 분석

- N개의 컴퓨터
- 한번의 해킹으로 여러개의 컴퓨터를 해킹하고 싶음
- A 컴퓨터가 B 컴퓨터를 신뢰할 경우 B 컴퓨터를 해킹하면 A도 해킹이 가능
- 입렵
    - 첫째줄
        - N, M
            - N = 10,0 00보다 작거나 같은 자연수
            - M = 100,000보다 작거나 같은 자연수
    - 둘째줄부터 M줄
        - 신뢰관계 A, B
            - A가 B를 신뢰
- 출력
    - 한번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터 번호를 오름차순을 출력

---

### 💡입출력 예시

```python
##input
5 4
3 1
3 2
4 3
5 3

##output
1 2
```

---

### 💡코드

```python
N, M = map(int, input().split())
dic = {}
for _ in range(M):
    A, B = map(int, input().split())
    if not B in dic:
        dic[B] = [A]
    else:
        dic[B].append(A)
answer = []
max_cnt = 0

def get_num(start, d):
    visited = [False] * (N+1)
    stack = [start]
    visited[start] = True
    cnt = 0

    while stack:
        u = stack.pop()
        for v in d.get(u, []):
            if not visited[v]:
                visited[v] = True
                cnt += 1
                stack.append(v)
    return cnt

for key in dic.keys():
    m = get_num(key, dic)
    if max_cnt == m:
        answer.append(key)
    if max_cnt < m:
        max_cnt = m
        answer = [key]

print(*sorted(answer))
```

---

### 💡메모

- 개선할만한 점
    - pypy대신 python으로도 풀리도록 개선

### 💡문제 분석

- N개의 컴퓨터
- 한번의 해킹으로 여러개의 컴퓨터를 해킹하고 싶음
- A 컴퓨터가 B 컴퓨터를 신뢰할 경우 B 컴퓨터를 해킹하면 A도 해킹이 가능
- 입렵
    - 첫째줄
        - N, M
            - N = 10,000보다 작거나 같은 자연수
            - M = 100,000보다 작거나 같은 자연수
    - 둘째줄부터 M줄
        - 신뢰관계 A, B
            - A가 B를 신뢰
- 출력
    - 한번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터 번호를 오름차순을 출력

---

### 💡입출력 예시

```python
##input
5 4
3 1
3 2
4 3
5 3

##output
1 2

```

---

### 💡코드

```python
N, M = map(int, input().split())
dic = {}
for _ in range(M):
    A, B = map(int, input().split())
    if not B in dic:
        dic[B] = [A]
    else:
        dic[B].append(A)
answer = []
max_cnt = 0

def get_num(start, d):
    visited = [False] * (N+1)
    stack = [start]
    visited[start] = True
    cnt = 0

    while stack:
        u = stack.pop()
        for v in d.get(u, []):
            if not visited[v]:
                visited[v] = True
                cnt += 1
                stack.append(v)
    return cnt

for key in dic.keys():
    m = get_num(key, dic)
    if max_cnt == m:
        answer.append(key)
    if max_cnt < m:
        max_cnt = m
        answer = [key]

print(*sorted(answer))

```

---

### 💡메모

- 개선할만한 점
    - pypy대신 python으로도 풀리도록 개선