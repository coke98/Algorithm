### 💡문제 분석

- 정가각형 칸들로 이루어진 사각형 모양 판이 존재
- 그위에 치즈들이 존재
    - 가장자리에는 치즈가 없음
    - 공기와 접촉된 칸은 한시간이 지나면 없어짐
- 입력:
    - 사각형 모양판의 세로와 가로 길이가 양의 정수로 주어짐
        - 세로, 가로는 최대 100
    - 이후 둘째줄부터 판의 가로줄 모양이 위에서부터 주어짐
        - 치즈가 없는 칸은 0 있는 칸은 1
- 출력:
    - 첫째 줄 치즈가 모두 녹아서 없어지는 시간
    - 둘째 줄 모두 녹기 한시간 전에 남아있는 치즈조각의 개수

---

### 💡입출력 예시

```python
# input
13 12
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 0 0 0
0 1 1 1 0 0 0 1 1 0 0 0
0 1 1 1 1 1 1 0 0 0 0 0
0 1 1 1 1 1 0 1 1 0 0 0
0 1 1 1 1 0 0 1 1 0 0 0
0 0 1 1 0 0 0 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0

# output
3
5

```

---

### 💡코드

```python
from collections import deque

N, M = map(int, input().split())

matrix = [list(map(int,input().split())) for _ in range(N)]

# 가장 끝을 공기로
for y in range(N):
    for x in range(M):
        if x == 0 or y == 0 or x == M-1 or y == N-1:
            matrix[y][x] = -1

# 없어질때까지 반복
hour = 1
while True:
    
    dx = [0, 0, 1, -1]
    dy = [1, -1, 0, 0]

    # 공기 찾기
    for y in range(N):
        for x in range(M):
            cur = matrix[y][x]
            if cur == 0:
                visited = [[0]*M for _ in range(N)]
                visited[y][x] = 1
                visited_node = []
                q = deque()
                q.append((x,y))
                visited_node.append((x,y))
                is_air = False
                while q:
                    x, y = q.popleft()
                    for i in range(4):
                        nx, ny = x+dx[i], y+dy[i]
                        if 0 <= nx < M and 0 <= ny < N and visited[ny][nx] == 0:
                            if matrix[ny][nx] == -1:
                                is_air = True
                            if matrix[ny][nx] == 0:
                                visited[ny][nx] = 1
                                visited_node.append((nx,ny))
                                q.append((nx,ny))
                        
                if is_air:
                    for x, y in visited_node:
                        matrix[y][x] = -1

    # 치즈 외곽선 찾고 공기로 변환

    remove = []
    for y in range(N):
        for x in range(M):
            cur = matrix[y][x]
            if cur == 1:
                for i in range(4):
                    nx, ny = x+dx[i], y+dy[i]
                    if 0 <= nx < M and 0 <= ny < N:
                        if matrix[ny][nx] == -1:
                            remove.append((x, y))
                            break
    for x, y in remove:
        matrix[y][x] = -1

    # 남은 치즈 여부 확인
    has_cheese = False
    for row in matrix:
        if 1 in row:
            has_cheese = True
            break
        
    if not has_cheese:
        print(hour)
        print(len(remove))
        break
    hour += 1
                        
                
```

---

### 💡시간복잡도

- O((NM)²)

### 💡공간복잡도

- O(NM)

---

### 💡메모

- 틀렸던 점
    - 상하좌우 경우마다 같은 치즈가 remove에 들어갈 수 있어서 남은 치즈 수가 더 많이 집계됨
- 개선할만한 점
    - 매 시간마다 한 번만 (0,0) 에서 외부 공기 BFS로
        - 방문했던 곳은 공기이므로 visited를 기준으로 외곽선 판별
        - O(NM)

        ```python
        from collections import deque
        
        N, M = map(int, input().split())
        
        matrix = [list(map(int,input().split())) for _ in range(N)]
        
        # 없어질때까지 반복
        hour = 1
        while True:
            
            dx = [0, 0, 1, -1]
            dy = [1, -1, 0, 0]
        
            visited = [[0]*M for _ in range(N)]
            
            # 공기 찾기
        
            visited[0][0] = 1
            q = deque()
            q.append((0,0))
            while q:
                x, y = q.popleft()
                for i in range(4):
                    nx, ny = x+dx[i], y+dy[i]
                    if 0 <= nx < M and 0 <= ny < N and visited[ny][nx] == 0:
                        if matrix[ny][nx] == 0:
                            visited[ny][nx] = 1
                            q.append((nx,ny))
        
            # 치즈 외곽선 찾고 공기로 변환
            remove = []
            for y in range(N):
                for x in range(M):
                    cur = matrix[y][x]
                    if cur == 1:
                        for i in range(4):
                            nx, ny = x+dx[i], y+dy[i]
                            if 0 <= nx < M and 0 <= ny < N:
                                if visited[ny][nx] == 1:
                                    remove.append((x, y))
                                    break
            for x, y in remove:
                matrix[y][x] = 0
        
            # 남은 치즈 여부 확인
            has_cheese = False
            for row in matrix:
                if 1 in row:
                    has_cheese = True
                    break
                
            if not has_cheese:
                print(hour)
                print(len(remove))
                break
            hour += 1
                                
                        
        ```