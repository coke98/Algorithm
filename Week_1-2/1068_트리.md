### 💡문제 분석

- 트리에서 리프 노드란 자식의 개수가 0인 노드
- 트리 노드 수 N (1 ≤ N ≤ 50)
- 각 노드의 부모 정보가 주어짐 (루트 노드는 -1)
- 지울 노드 R이 주어짐
    - 노드를 지우면 그 노드와 모든 자손이 제거됨
- 제거 후 남은 트리에서 리프 노드 개수를 구해야함
- 입력
    - 첫째 줄에 노드의 개수 N
    - 둘째 줄에 0번 노드부터 N‒1번 노드까지 부모 정보
    - 셋째 줄에 지울 노드 번호 R
      출력
- 출력
    - 남은 트리의 리프 노드 개수

---

### 💡입출력 예시

```python
##input
5
-1 0 0 1 1
2

##output
2

##input2
5
-1 0 0 1 1
1

##output2
1

##input3
5
-1 0 0 1 1
0

##output3
0

##input4
9
-1 0 0 2 2 4 4 6 6
4

##output4
2
```

---

### 💡코드

```python
from collections import deque

N = int(input())
nodes = list(map(int,input().split()))
T = int(input())

def get_leaf(l):
    parent = set()
    for node in l:
        if node == -1:
            continue
        parent.add(node)
    return len(l) - len(parent)

res = []
exc = set()
exc.add(T)
q = deque()
q.append(T)
while q:
    cur = q.popleft()
    for i, node in enumerate(nodes):
        if node == cur:
            q.append(i)
            exc.add(i)
    
for i, node in enumerate(nodes):
    if not i in exc:
        res.append(node)

print(get_leaf(res))
```

---

### 💡시간복잡도

- O(N²)

### 💡공간복잡도

- O(N)

---

### 💡메모

- 몰랐던 점
    - 노드 숫자들이 오름차순으로 들어오지는 않을 수 있음
        - 반복문 하나로 해결하려다가 BFS로 변경
- 틀렸던 점
    - 마지막에 집계할때 enumerate의 값과 인덱스를 혼동해서 사용